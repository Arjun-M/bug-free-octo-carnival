/**\n * @fileoverview Strict timeout enforcement with infinite loop detection\n */\n\nimport { EventEmitter } from 'events';\nimport type { Isolate } from 'isolated-vm';\nimport { TimeoutError } from '../core/types.js';\nimport { logger } from '../utils/Logger.js';\n\n/**\n * Handle for an active timeout\n */\nexport interface TimeoutHandle {\n  /** Interval ID for the monitoring loop */\n  intervalId: NodeJS.Timeout;\n  /** Isolate being monitored */\n  isolate: Isolate;\n  /** Start time of timeout */\n  startTime: number;\n  /** Timeout duration in milliseconds */\n  timeoutMs: number;\n  /** Whether timeout has been triggered */\n  triggered: boolean;\n  /** Reason for timeout if triggered */\n  reason?: string;\n}\n\n/**\n * Manages strict execution timeouts with infinite loop detection\n *\n * Key behavior:\n * - Hard timeout: isolate.dispose() is called immediately when timeout exceeded\n * - Infinite loop detection: if CPU time ≈ wall-clock time (>95%), likely infinite loop\n * - Monitoring interval: 10ms for responsive timeout enforcement\n * - Strict kill: no graceful shutdown, direct disposal\n */\nexport class TimeoutManager {\n  private timeouts: Map<string, TimeoutHandle> = new Map();\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private monitoringInterval: number = 10; // 10ms monitoring interval\n  private infiniteLoopThreshold: number = 0.95; // 95% CPU usage = likely infinite loop\n  private minDetectionTime: number = 100; // Require 100ms before declaring infinite loop\n\n  /**\n   * Start a timeout for an isolate with strict enforcement\n   * @param isolate The isolate to monitor\n   * @param timeoutMs Timeout duration in milliseconds\n   * @param strictKill Whether to force immediate disposal (true) or graceful shutdown (false)\n   * @param timeoutId Optional ID for the timeout (generated if not provided)\n   * @returns Handle for managing the timeout\n   */\n  startTimeout(\n    isolate: Isolate,\n    timeoutMs: number,\n    strictKill: boolean = true,\n    timeoutId?: string\n  ): TimeoutHandle {\n    const id = timeoutId || `timeout-${Date.now()}-${Math.random()}`;\n\n    if (this.timeouts.has(id)) {\n      throw new Error(`Timeout ${id} already exists`);\n    }\n\n    const startTime = Date.now();\n    let lastCpuTime = 0;\n\n    logger.debug(`Starting timeout for ${timeoutMs}ms (strict=${strictKill})`);\n\n    // Monitor loop: check timeout and infinite loops every 10ms\n    const intervalId = setInterval(() => {\n      const elapsed = Date.now() - startTime;\n      const cpuTimeMs = this.getCpuTimeMs(isolate);\n      const handle = this.timeouts.get(id);\n\n      if (!handle || handle.triggered) {\n        clearInterval(intervalId);\n        return;\n      }\n\n      // Check 1: Wall-clock timeout exceeded\n      if (elapsed >= timeoutMs) {\n        logger.warn(`Timeout exceeded after ${elapsed}ms, killing isolate`);\n        this.killIsolate(isolate, id, 'timeout');\n        return;\n      }\n\n      // Check 2: Infinite loop detection (CPU time ≈ wall-clock time)\n      const cpuPercent = elapsed > 0 ? cpuTimeMs / elapsed : 0;\n\n      if (\n        cpuPercent >= this.infiniteLoopThreshold &&\n        elapsed >= this.minDetectionTime\n      ) {\n        logger.warn(\n          `Infinite loop detected (${(cpuPercent * 100).toFixed(1)}% CPU after ${elapsed}ms), killing isolate`\n        );\n        this.killIsolate(isolate, id, 'infinite-loop');\n        return;\n      }\n\n      // Check 3: Gradual timeout warning at 80% of timeout\n      if (elapsed >= timeoutMs * 0.8 && lastCpuTime < timeoutMs * 0.8) {\n        logger.debug(`Approaching timeout (${elapsed}ms / ${timeoutMs}ms)`);\n        this.eventEmitter.emit('warning', {\n          id,\n          elapsed,\n          timeout: timeoutMs,\n          cpuTime: cpuTimeMs,\n          severity: 'high',\n        });\n      }\n\n      lastCpuTime = cpuTimeMs;\n    }, this.monitoringInterval);\n\n    const handle: TimeoutHandle = {\n      intervalId,\n      isolate,\n      startTime,\n      timeoutMs,\n      triggered: false,\n    };\n\n    this.timeouts.set(id, handle);\n    return handle;\n  }\n\n  /**\n   * Start CPU time monitoring for a specific limit\n   * @param isolate The isolate to monitor\n   * @param cpuLimitMs CPU time limit in milliseconds\n   * @param timeoutId Optional ID for the timeout\n   * @returns Handle for managing the timeout\n   */\n  startCpuMonitoring(\n    isolate: Isolate,\n    cpuLimitMs: number,\n    timeoutId?: string\n  ): TimeoutHandle {\n    const id = timeoutId || `cpu-monitor-${Date.now()}-${Math.random()}`;\n\n    if (this.timeouts.has(id)) {\n      throw new Error(`Timeout ${id} already exists`);\n    }\n\n    const startTime = Date.now();\n\n    logger.debug(`Starting CPU monitoring with limit ${cpuLimitMs}ms`);\n\n    const intervalId = setInterval(() => {\n      const cpuTimeMs = this.getCpuTimeMs(isolate);\n      const handle = this.timeouts.get(id);\n\n      if (!handle || handle.triggered) {\n        clearInterval(intervalId);\n        return;\n      }\n\n      // CPU time exceeded limit\n      if (cpuTimeMs >= cpuLimitMs) {\n        logger.warn(`CPU limit exceeded (${cpuTimeMs}ms / ${cpuLimitMs}ms), killing isolate`);\n        this.killIsolate(isolate, id, 'cpu-limit');\n        return;\n      }\n\n      // Warning at 80% of CPU limit\n      if (cpuTimeMs >= cpuLimitMs * 0.8) {\n        this.eventEmitter.emit('warning', {\n          id,\n          cpuTime: cpuTimeMs,\n          cpuLimit: cpuLimitMs,\n          severity: 'high',\n        });\n      }\n    }, this.monitoringInterval);\n\n    const handle: TimeoutHandle = {\n      intervalId,\n      isolate,\n      startTime,\n      timeoutMs: cpuLimitMs,\n      triggered: false,\n    };\n\n    this.timeouts.set(id, handle);\n    return handle;\n  }\n\n  /**\n   * Detect if an isolate is likely in an infinite loop\n   * @param isolate Isolate to check\n   * @param wallTimeMs Wall-clock time elapsed\n   * @returns True if likely infinite loop\n   */\n  detectInfiniteLoop(isolate: Isolate, wallTimeMs: number = 0): boolean {\n    if (wallTimeMs < this.minDetectionTime) {\n      return false;\n    }\n\n    const cpuTimeMs = this.getCpuTimeMs(isolate);\n    const cpuPercent = wallTimeMs > 0 ? cpuTimeMs / wallTimeMs : 0;\n\n    return cpuPercent >= this.infiniteLoopThreshold;\n  }\n\n  /**\n   * Kill an isolate with immediate disposal\n   * @param isolate Isolate to kill\n   * @param timeoutId Timeout ID\n   * @param reason Reason for killing\n   */\n  private killIsolate(isolate: Isolate, timeoutId: string, reason: string): void {\n    const handle = this.timeouts.get(timeoutId);\n\n    if (handle) {\n      handle.triggered = true;\n      handle.reason = reason;\n      clearInterval(handle.intervalId);\n    }\n\n    try {\n      // Hard kill: immediate disposal with no cleanup\n      (isolate as any).dispose?.();\n    } catch (err) {\n      logger.debug(`Error disposing isolate: ${err instanceof Error ? err.message : String(err)}`);\n    }\n\n    this.timeouts.delete(timeoutId);\n\n    logger.info(`Isolate killed (reason: ${reason})`);\n    this.eventEmitter.emit('timeout', {\n      id: timeoutId,\n      reason,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Clear a timeout without killing the isolate\n   * @param timeoutId Timeout ID to clear\n   */\n  clearTimeout(timeoutId: string): void {\n    const handle = this.timeouts.get(timeoutId);\n\n    if (handle) {\n      clearInterval(handle.intervalId);\n      this.timeouts.delete(timeoutId);\n      logger.debug(`Timeout cleared for ${timeoutId}`);\n    }\n  }\n\n  /**\n   * Get CPU time from an isolate in milliseconds\n   * @param isolate Isolate to get CPU time from\n   * @returns CPU time in milliseconds\n   */\n  private getCpuTimeMs(isolate: Isolate): number {\n    try {\n      // isolated-vm exposes cpuTime in microseconds\n      const cpuTimeUs = (isolate as any).cpuTime || 0;\n      return cpuTimeUs / 1000; // Convert to milliseconds\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Register event listener\n   * @param event Event name\n   * @param handler Handler function\n   */\n  on(event: string, handler: (...args: any[]) => void): void {\n    this.eventEmitter.on(event, handler);\n  }\n\n  /**\n   * Remove event listener\n   * @param event Event name\n   * @param handler Handler function\n   */\n  off(event: string, handler: (...args: any[]) => void): void {\n    this.eventEmitter.off(event, handler);\n  }\n\n  /**\n   * Get all active timeouts\n   * @returns Array of timeout IDs\n   */\n  getActiveTimeouts(): string[] {\n    return Array.from(this.timeouts.keys());\n  }\n\n  /**\n   * Clear all timeouts\n   */\n  clearAll(): void {\n    for (const id of this.timeouts.keys()) {\n      this.clearTimeout(id);\n    }\n  }\n\n  /**\n   * Get timeout statistics\n   * @returns Statistics object\n   */\n  getStats(): {\n    activeTimeouts: number;\n    triggeredTimeouts: number;\n  } {\n    const triggered = Array.from(this.timeouts.values()).filter(\n      (h) => h.triggered\n    ).length;\n\n    return {\n      activeTimeouts: this.timeouts.size - triggered,\n      triggeredTimeouts: triggered,\n    };\n  }\n\n  /**\n   * Set infinite loop detection threshold\n   * @param percent CPU percent (0-1) above which to trigger\n   */\n  setInfiniteLoopThreshold(percent: number): void {\n    if (percent < 0 || percent > 1) {\n      throw new Error('Threshold must be between 0 and 1');\n    }\n    this.infiniteLoopThreshold = percent;\n  }\n\n  /**\n   * Set minimum time before infinite loop detection\n   * @param ms Minimum elapsed time in milliseconds\n   */\n  setMinDetectionTime(ms: number): void {\n    if (ms < 0) {\n      throw new Error('Detection time must be non-negative');\n    }\n    this.minDetectionTime = ms;\n  }\n}\n